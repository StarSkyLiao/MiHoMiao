using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MiHoMiao.xGenerator.Codec;

[Generator(LanguageNames.CSharp)]
public sealed class AutoComplexCodecGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        // 1. 语法 + 语义一步拿到
        var records = ctx.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is RecordDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) =>
                {
                    var decl = (TypeDeclarationSyntax)ctx.Node;
                    var symbol = ctx.SemanticModel.GetDeclaredSymbol(decl);
                    return (decl, symbol);
                })
            .Where(static t => t.symbol != null && t.symbol.HasAttribute("AutoComplexCodec"));

        // 2. 为每个 record 生成代码
        ctx.RegisterSourceOutput(records, static (spc, tuple) =>
        {
            var (syntax, symbol) = tuple;
            if (symbol is null) return;

            var ns = symbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : symbol.ContainingNamespace.ToDisplayString();

            var code = GenerateImplementation(symbol, ns);
            var fileName = $"{symbol.Name}.AutoComplexCodec.g.cs";
            spc.AddSource(fileName, SourceText.From(code, Encoding.UTF8));
        });
    }

    private static string GenerateImplementation(INamedTypeSymbol record, string? ns)
    {
        var name = record.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat); // 包含泛型参数
        var paramTypes = record.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .Select(p => p.Type)
            .ToImmutableArray();

        var interfaceImpl = BuildInterface(record, paramTypes);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        if (ns != null) sb.AppendLine($"namespace {ns};").AppendLine();

        sb.AppendLine($"partial {(record.IsValueType ? "record struct" : "record")} {name} : {interfaceImpl}");
        sb.AppendLine("{");

        // CreateSelf
        var ctorPars = string.Join(", ", paramTypes.Select((t, i) => $"{t.ToDisplayString()} param{i}"));
        var ctorArgs = string.Join(", ", paramTypes.Select((_, i) => $"param{i}"));
        sb.AppendLine($"    public static {name} CreateSelf({ctorPars}) => new {name}({ctorArgs});");

        // LoadT1 … LoadTN
        var props = record.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToImmutableArray();
        for (int i = 0; i < props.Length; i++)
        {
            sb.AppendLine(
                $"    public static {paramTypes[i].ToDisplayString()} LoadT{i + 1}({name} self) => self.{props[i].Name};");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string BuildInterface(INamedTypeSymbol record, ImmutableArray<ITypeSymbol> paramTypes)
    {
        var sb = new StringBuilder();
        sb.Append("global::MiHoMiao.Core.Serialization.Codec.Internal.IComplexCodec<");
        sb.Append(record.ToDisplayString()).Append(", ");

        foreach (ITypeSymbol? t in paramTypes)
        {
            sb.AppendLine();
            sb.Append(LoadCodecType(t)).Append(", ").Append(t.ToDisplayString()).Append(", ");
        }

        if (paramTypes.Length > 0) sb.Length -= 2;
        sb.Append('>');
        return sb.ToString();
    }

    private const string CodecNamespace = "global::MiHoMiao.Core.Serialization.Codec.Internal.";

    private static string LoadCodecType(ITypeSymbol t)
    {
        // 字符串
        if (t is { SpecialType: SpecialType.System_String }) return CodecNamespace + "StringCodec";
        // Unmanaged 数组
        if (t is IArrayTypeSymbol arrayType && IsRecursiveValueOnly(arrayType.ElementType))
            return $"{CodecNamespace}NativeArrayCodec<{arrayType.ElementType.ToDisplayString()}>";
        // 字符串数组
        if (t is IArrayTypeSymbol { ElementType.SpecialType: SpecialType.System_String })
            return $"{CodecNamespace}ObjectArrayCodec<{CodecNamespace}StringCodec, string>";
        // 其它数组
        if (t is IArrayTypeSymbol arr2)
        {
            string name = LoadCodecType(arr2.ElementType);
            return $"{CodecNamespace}ObjectArrayCodec<{name}, {arr2.ElementType.ToDisplayString()}>";
        }
        // 4. 已知原语或枚举 → UnmanagedCodec
        if (IsRecursiveValueOnly(t))
            return $"{CodecNamespace}UnmanagedCodec<{t.ToDisplayString()}>";
        return t.ToDisplayString();
    }

    private static readonly HashSet<SpecialType> s_SpecialType =
    [
        SpecialType.System_Boolean,
        SpecialType.System_Byte, SpecialType.System_SByte,
        SpecialType.System_Int16, SpecialType.System_UInt16,
        SpecialType.System_Int32, SpecialType.System_UInt32,
        SpecialType.System_Int64, SpecialType.System_UInt64,
        SpecialType.System_Single, SpecialType.System_Double,
        SpecialType.System_Decimal, SpecialType.System_IntPtr,
        SpecialType.System_UIntPtr,
        SpecialType.System_Char,
    ];

    /// <summary>
    /// 简易递归检查：所有字段都是原语或枚举或 readonly struct 且继续满足本条件。
    /// 只要出现任何引用类型字段/属性就返回 false。
    /// </summary>
    private static bool IsRecursiveValueOnly(ITypeSymbol t)
    {
        if (t.TypeKind == TypeKind.Enum) return true;
        if (s_SpecialType.Contains(t.SpecialType)) return true;
        if (t.IsReferenceType) return false;
        // 原语快速路径
        if (t.SpecialType != SpecialType.None) return true;
        if (t is not { IsValueType: true, IsRefLikeType: false}) return false;
        // 对 struct 检查所有实例字段
        foreach (ISymbol? member in t.GetMembers())
        {
            switch (member)
            {
                case IPropertySymbol { IsStatic: true }: continue;
                case IPropertySymbol { Type.IsReferenceType: true }: return false;
                case IPropertySymbol { Type.TypeKind: TypeKind.Enum }: continue;
                case IPropertySymbol property when property.Type.SpecialType != SpecialType.None: continue;
                // 嵌套 struct 必须也是 readonly 且继续递归
                case IPropertySymbol property:
                {
                    if (property.Type is not INamedTypeSymbol { IsValueType: true, IsReadOnly: true } nested) continue;
                    return !IsRecursiveValueOnly(nested) && false; // 出现非安全字段
                }
                case IFieldSymbol { IsStatic: true }: continue;
                case IFieldSymbol { Type.IsReferenceType: true }: return false;
                case IFieldSymbol { Type.TypeKind: TypeKind.Enum }: continue;
                case IFieldSymbol field when field.Type.SpecialType != SpecialType.None: continue;
                // 嵌套 struct 必须也是 readonly 且继续递归
                case IFieldSymbol field:
                {
                    if (field.Type is not INamedTypeSymbol { IsValueType: true, IsReadOnly: true } nested) continue;
                    return !IsRecursiveValueOnly(nested) && false; // 出现非安全字段
                }
            }
        }
        return true;
    }
}

internal static class SymbolExtensions
{
    public static bool HasAttribute(this INamedTypeSymbol symbol, string shortName)
        => symbol.GetAttributes()
            .Any(ad => ad.AttributeClass?.Name == shortName ||
                       ad.AttributeClass?.Name == shortName + "Attribute");
}